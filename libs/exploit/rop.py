"""
ROP Chain Builder Module

Provides utilities for building Return-Oriented Programming (ROP) chains.
"""

from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass


@dataclass
class ROPGadget:
    """Represents a ROP gadget."""
    address: int
    instructions: str
    registers: List[str]  # Registers this gadget affects
    stack_adjust: int = 0  # Stack pointer adjustment


class ROPChainBuilder:
    """
    Builder for ROP chains.
    
    Helps construct ROP chains for exploitation.
    """
    
    def __init__(self, arch: str = 'x86_64'):
        """
        Initialize ROP chain builder.
        
        Args:
            arch: Target architecture
        """
        self.arch = arch
        self.gadgets: List[ROPGadget] = []
        self.chain: List[ROPGadget] = []
        self.base_address: Optional[int] = None
    
    def set_base_address(self, address: int) -> None:
        """
        Set base address for gadgets.
        
        Args:
            address: Base address
        """
        self.base_address = address
    
    def add_gadget(self, gadget: ROPGadget) -> None:
        """
        Add a gadget to the available gadgets.
        
        Args:
            gadget: ROP gadget
        """
        self.gadgets.append(gadget)
    
    def find_gadget(self, pattern: str) -> Optional[ROPGadget]:
        """
        Find a gadget matching a pattern.
        
        Args:
            pattern: Pattern to search for in instructions
            
        Returns:
            Matching gadget or None
        """
        for gadget in self.gadgets:
            if pattern in gadget.instructions.lower():
                return gadget
        return None
    
    def build_chain(self, goal: str, **kwargs) -> List[ROPGadget]:
        """
        Build a ROP chain for a specific goal.
        
        Args:
            goal: Goal of the chain ('call_function', 'write_memory', 'read_memory', etc.)
            **kwargs: Parameters for the goal
            
        Returns:
            List of gadgets in the chain
        """
        self.chain = []
        
        if goal == 'call_function':
            return self._build_function_call_chain(**kwargs)
        elif goal == 'write_memory':
            return self._build_write_memory_chain(**kwargs)
        elif goal == 'read_memory':
            return self._build_read_memory_chain(**kwargs)
        else:
            raise ValueError(f"Unknown goal: {goal}")
    
    def _build_function_call_chain(self, function: str, args: List[int]) -> List[ROPGadget]:
        """
        Build chain to call a function.
        
        Args:
            function: Function name or address
            args: Function arguments
            
        Returns:
            ROP chain
        """
        chain = []
        
        # Find pop gadgets for arguments
        if self.arch == 'x86_64':
            # x86-64 calling convention: rdi, rsi, rdx, rcx, r8, r9
            regs = ['rdi', 'rsi', 'rdx', 'rcx', 'r8', 'r9']
            for i, arg in enumerate(args[:6]):
                pop_gadget = self.find_gadget(f'pop {regs[i]}')
                if pop_gadget:
                    chain.append(pop_gadget)
        
        return chain
    
    def _build_write_memory_chain(self, address: int, value: int) -> List[ROPGadget]:
        """Build chain to write memory."""
        # Placeholder implementation
        return []
    
    def _build_read_memory_chain(self, address: int) -> List[ROPGadget]:
        """Build chain to read memory."""
        # Placeholder implementation
        return []
    
    def to_bytes(self) -> bytes:
        """
        Convert ROP chain to bytes.
        
        Returns:
            ROP chain as bytes
        """
        chain_bytes = bytearray()
        
        for gadget in self.chain:
            if self.base_address:
                addr = self.base_address + gadget.address
            else:
                addr = gadget.address
            
            # Pack address based on architecture
            if self.arch == 'x86_64':
                chain_bytes.extend(addr.to_bytes(8, byteorder='little'))
            elif self.arch == 'x86':
                chain_bytes.extend(addr.to_bytes(4, byteorder='little'))
            else:
                raise ValueError(f"Unsupported architecture: {self.arch}")
        
        return bytes(chain_bytes)
    
    def to_string(self) -> str:
        """
        Convert ROP chain to string representation.
        
        Returns:
            Human-readable chain
        """
        lines = []
        for i, gadget in enumerate(self.chain):
            addr = self.base_address + gadget.address if self.base_address else gadget.address
            lines.append(f"  [{i}] 0x{addr:x}: {gadget.instructions}")
        return '\n'.join(lines)
    
    def clear(self) -> None:
        """Clear the current chain."""
        self.chain = []

